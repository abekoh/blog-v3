---
slug: 'starting-java-performance-tuning'
title: 'Javaでパフォーマンスを意識した開発を行っていく上での心得'
summary: '仕事でパフォーマンス要件の厳しいJavaアプリケーションを開発することになったので、
いくつかの書籍や実体験をもとに肝に銘じておくべきことをまとめてみます。'
categories: ['tech']
tags: ['java','jvm','performance-tuning']
publishedAt: 2021-05-02T15:24:00.000Z
modifiedAt: 
draft: false
isHtml: true
microCMSId: 'starting-java-performance-tuning'
microCMSCreatedAt: 2021-05-01T13:26:24.390Z
microCMSUpdatedAt: 2021-10-13T11:25:37.901Z
microCMSRevisedAt: 2021-10-13T11:25:37.901Z
---
<p>仕事でパフォーマンス要件の厳しいJavaアプリケーションを開発することになったので、<br>いくつかの書籍や実体験をもとに肝に銘じておくべきことをまとめてみます。<br><br>なお、この記事で出てくる「テスト」は、特に注記がない限り「パフォーマンステスト」の指します。<br></p><h2 id="h48ef4939fb">小手先のチューニングのために「コードの読みやすさ」を犠牲にしない</h2><p>「パフォーマンスのためならば可読性を削ってでも最適化された設計をしていくべき」<br>これは良くない考え方です。<br>考えられる例としては、「クラスファイルを可能な限り減らす」「何でもstaticとして定義する」「変数名をとにかく短いものにする」といったことでしょうか。<br><br>Donald E. Knuth先生の格言として次のようなものがあります。<br>「わずかな効率、たとえば時間の約97%については忘れるべきである。時期尚早の最適化は、すべての悪の根源である。」<br>ここでの最適化は「コードを複雑化させ、読みやすさを犠牲にしつつパフォーマンスを生み出すもの」と解釈します。<br><strong>何でもすぐに最適化に手を付けるのではなく、実際にテスト・計測を実施して明らかにボトルネックになるとわかったそのとき初めて検討しましょう。</strong><br><br>誤った最適化によるコードは、その後修正しにくい形で残ってしまうでしょう。俗に(厳密な定義はさておき)技術的負債とも呼ばれます。<br>パフォーマンスのためと括って書いたコードに、後々返り討ちに遭うことになるかもしれないので要注意です。<br></p><h2 id="hc8445f5076">事実ベースでチューニングを行う</h2><p>前項と重複しますが、テストの測定結果、プロファイリングなどの<strong>事実を根拠</strong>にチューニングを実施しましょう。<br>憶測だけでチューニングを行っても、期待した結果が得られないかもしれません。<br><br>Javaの場合、優秀なJITコンパイラによって頻繁に実行される箇所が最適化されていきます。(HotSpot JVMを利用した想定です)<br>「ここがパフォーマンス悪化の原因！」と直してみた箇所も、実はJITコンパイラの最適化結果と変わらない、むしろ悪化するかもしれません。<br><a href="https://visualvm.github.io/download.html" target="_blank" rel="noopener noreferrer">VisualVM</a>といったツールを用いてプロファイリングを実施し、パフォーマンス悪化した部分を特定して改善することが効果的です。<br></p><h2 id="h1ef1ffe400">可能な限り実環境でテストをする</h2><p>実際のアプリケーションを使い、実際に動く環境で、実際の使い方でテストを行いましょう。<br>場合によっては難しいかもしれませんが、可能な限り近い条件でテストすべきです。<br><br>テストの分類として、マイクロベンチマークというものがあります。<br>これはアプリケーションのコードの一部など、ユニットテストぐらいの手軽さのテストです。<br>Javaだと<a href="https://github.com/openjdk/jmh" target="_blank" rel="noopener noreferrer">JMH</a>というライブラリが有名のようです。<br><br>もちろんここれでもコードの処理が速い/遅いをチェックできますが、あくまで参考値です。<br>実際のアプリケーションではCPU、メモリ、ネットワーク、I/Oなどなど別に問題があるかもしれません。<br>マイクロベンチマークの優先順位としては後にしておき、まずは全体は実環境に近いテスト環境を整えたほうが良いでしょう。<br></p><h2 id="h8125e67986">複数のパフォーマンスの観点を考慮し、目標を設定する</h2><p>一口にパフォーマンスといっても、指標は様々です。例を挙げると、</p><ul><li>スループット … 一定時間内にどれだけのリクエストを処理できるか？</li><li>レスポンスタイムの平均値 … 平均でどれだけの時間で返却するか？</li><li>レスポンスタイムのパーセンタイル値 … 99％のリクエストのうち最も遅いのは？(1%の外れ値は？)</li></ul><p>このようなものがあります。<br>要件によって目標値は違ってくると思います。テストを実施する前に、予め目標を決め、それにあった指標を取ることを忘れないようにしましょう。<br></p><h2 id="hb86983428f">テスト結果のブレに注意</h2><p>全く同じアプリケーションで全く同じリクエストであっても、実行のたびに結果が異なることがあります。<br>動作環境の別プロセスの影響、ネットワークの混み具合など理由は様々です。<br><br>このブレを認識し、統計的な有意さを求めるためにt検定といったアプローチを取ることも可能です。<br>しかし、結果を求めるためにテストを複数回行うなど、現実的でない・手間がかかるといったことが考えられるでしょう。<br><br><strong>大切なのは、このブレについて認識しておくことです。</strong><br>ある程度の結果のブレを認めた上で、改善のためにコストをかけましょう。<br></p><h2 id="haef65dbb5f">早期から頻繁にテストを実施する</h2><p>開発サイクルの中にパフォーマンステストを組み込むことが理想です。<br>常にテストを実施することで、「どの変更によりどう影響が出たのか」明確になり、早期に修正も可能となります。<br><br>開発サイクルに組み込む場合、自動化することが理想です。<br>CIパイプラインを利用している場合、デプロイ前or後にテスト用ジョブを設けると良いでしょう。<br><br>また、テスト時の測定値は分析に使えるものはすべて収集しておくことが望ましいです。<br>レスポンスタイム平均・パーセンタイル値はもちろん、実行環境のスペック、プロファイルデータなどアプリケーションに関する情報についてもです。<br><br>---<br><br>以下はJava(もしくはJVM言語)特有の話となります。<br>様々な最適化テクニックを行う前の、前提として心がけるべき点だけ挙げます。<br></p><h2 id="h5ddaf5846b">ウォームアップを必ず実施する</h2><p>Javaを動かす実装は、多くの場合HotSpot JVMと想定されます。<br>このJVMはホットな箇所、つまり何度も実行される部分のみをコンパイルし最適化していきます。<br>これはビルド時や初回リクエスト時ではなく、何度もリクエストされながら適宜行われます。<br>(「最初は舗装されてない道だらけだが、たくさん車が通る道を見つけては舗装する」というイメージ)<br><br>よって、起動直後のJavaアプリケーションは最適化されておらず、十分なパフォーマンスは出ないでしょう。<br>そのためにウォームアップ(暖機運転)を実施すべきです。<br><br>ウォームアップのやり方は簡単で、起動後に想定されるリクエストを何百～何千回か投げればOKです。<br>パフォーマンス計測時はもちろん、サービスインの直前に行っておくのが理想です。<br><br>具体的なプラクティスは次の記事が参考になります。(kubernetesで動かす前提の記事ですが。。)</p><ul><li><a href="https://techblog.zozo.com/entry/zozomat-jvm-warmup" target="_blank" rel="noopener noreferrer">ZOZOMATにおけるJVMの暖機運転の導入と改善効果について - ZOZO Technologies TECH BLOG</a></li><li><a href="https://speakerdeck.com/hhiroshell/jvm-on-kubernetes" target="_blank" rel="noopener noreferrer">KubernetesでJVMアプリを動かすための実践的ノウハウ集 / JVM on Kubernetes - Speaker Deck</a></li></ul><p><br></p><h2 id="hf473d27a75">闇雲にJVMパラメータを設定しない</h2><p>ネット上や書籍を漁ると、「このオプションは設定すべき」「この値はこれくらいがベスト」といった多くのプラクティスが見つかります。<br>どのオプションを使うor使わないの判断は、必ず根拠をもって行うようにしましょう。<br><br>オプションによっては、バージョンが変わったことによりデフォルトでも効くようになっていることもあります。<br>メジャーバージョンだけでなく、マイナーバージョンアップでもその可能性はあります。<br>例えば、Docker上でCPU/メモリを正しくホストを認識させる設定<code>-XX:+UseContainerSupport</code><span style="color:#161513">は、同じJava 8の</span><a style="color:#161513" href="https://www.oracle.com/java/technologies/javase/8u191-relnotes.html#JDK-8146115" target="_blank" rel="noopener noreferrer">8u191</a><span style="color:#161513">以降で不要となりました。</span><br>本当に設定すべきか情報収集を行ってから対応しましょう。<br><br>また、JVMオプションを追加した場合はその根拠もどこかに残しておくべきです。<br>さもないと後々「なぜ設定されてるかわからないけど外そうにも外せない」ということになってしまいます。<br>後世のためにもコメントやドキュメントに残しておきましょう。<br><br></p><h2 id="h44e51f96ce">参考資料</h2><h3 id="hf0acdfab67"><a href="https://www.oreilly.co.jp/books/9784873117188/" target="_blank" rel="noopener noreferrer">Javaパフォーマンス</a></h3><p>Javaのパフォーマンスチューニングに関して、原則から測定方法、JVMチューニングやコードのプラクティスまで幅広く扱われています。<br>いくつかのGCのアルゴリズムについてもこの書籍で学べます。<br>バージョンはJava 7,8に基づいて書かれています。<br><br>なお、本記事はこの書籍の第1章、第2章をベースにしております。<br></p><h3 id="h2296c0dfc4"><a href="https://www.maruzen-publishing.co.jp/item/?book_no=303054" target="_blank" rel="noopener noreferrer">Effective Java 第3版</a></h3><p>言わずとしれた名著です。<br>パフォーマンスに関して特に関係があるのは「項目67 注意して最適化する」が挙げられます。他にも最適化に関する内容はいくつか見られます。<br>バージョンはJava 9に基づいて書かれています。</p>
    